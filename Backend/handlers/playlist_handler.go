package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
)

const (
	createPlaylistUrl = "https://api.spotify.com/v1/users/%s/playlists"
	addTracksURL = "https://api.spotify.com/v1/playlists/%s/tracks"
	searchURL = "https://api.spotify.com/v1/search"
)

type SpotifySearchResponse struct {
	Tracks struct {
		Items []struct {
			URI string `json:"uri"`
		} `json:"items"`
	} `json:"tracks"`
}

type CreatePlaylistBody struct {
	Name string `json:"name"`
	Description string `json:"description"`
	Public bool `json:"public"`
}

type CreatePlaylistResponse struct {
	ID  string `json:"id"`
	ExternalURLs struct {
		Spotify string `json:"spotify"`
	} `json:"external_urls"`
}

type AddTracksTBody struct {
	URIs []string `json:"uris"`
}

type SpotifyUserProfile struct {
	ID string `json:"id"`
}

type PlaylistRequest struct {
	PlaylistName string `json:"playlist_name"`
	Songs []struct {
		Title string `json:"title"`
		Artist string `json:"artist"`
	} `json:"songs"`
}

func HandleCreatePlaylist(w http.ResponseWriter, r *http.Request) {
	claims, ok := r.Context().Value("userClaims").(*Claims)
	if !ok {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var req PlaylistRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Bad Request", http.StatusBadRequest)
		return
	}

	if claims == nil || claims.AccessToken == "" {
		http.Error(w, "Spotify Access Token is missing", http.StatusUnauthorized)
		return
	}

	token := claims.AccessToken

	// Step 1: Get user profile to get user ID
	userProfile, err := getSpotifyUserProfile(token)
	if err != nil {
		http.Error(w, "Failed to get user profile: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Step 2: Create playlist
	playlist, err := createSpotifyPlaylist(token, userProfile.ID, req.PlaylistName)
	if err != nil {
		http.Error(w, "Failed to create playlist: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Step 3: Search for songs and get their URIs
	var trackURIs []string
	for _, song := range req.Songs {
		uri, err := searchSpotifyTrack(token, song.Title, song.Artist)
		if err != nil {
			// Log error but continue with other songs
			fmt.Printf("Failed to find track %s by %s: %v\n", song.Title, song.Artist, err)
			continue
		}
		if uri != "" {
			trackURIs = append(trackURIs, uri)
		}
	}

	// Step 4: Add tracks to playlist
	if len(trackURIs) > 0 {
		err = addTracksToPlaylist(token, playlist.ID, trackURIs)
		if err != nil {
			http.Error(w, "Failed to add tracks to playlist: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}

	// Step 5: Return success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message": "Playlist created successfully",
		"playlist_id": playlist.ID,
		"playlist_url": playlist.ExternalURLs.Spotify,
		"playlist_name": req.PlaylistName,
		"songs_requested": len(req.Songs),
		"songs_added": len(trackURIs),
	})
}

// Helper function to get Spotify user profile
func getSpotifyUserProfile(accessToken string) (*SpotifyUserProfile, error) {
	req, err := http.NewRequest("GET", "https://api.spotify.com/v1/me", nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("failed to get user profile: %s - %s", resp.Status, string(body))
	}

	var userProfile SpotifyUserProfile
	if err := json.NewDecoder(resp.Body).Decode(&userProfile); err != nil {
		return nil, err
	}

	return &userProfile, nil
}

// Helper function to create a Spotify playlist
func createSpotifyPlaylist(accessToken, userID, playlistName string) (*CreatePlaylistResponse, error) {
	playlistData := CreatePlaylistBody{
		Name:        playlistName,
		Description: "Generated by Moodify - AI-powered mood-based playlist",
		Public:      false,
	}

	jsonData, err := json.Marshal(playlistData)
	if err != nil {
		return nil, err
	}

	url := fmt.Sprintf(createPlaylistUrl, userID)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated && resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("failed to create playlist: %s - %s", resp.Status, string(body))
	}

	var playlist CreatePlaylistResponse
	if err := json.NewDecoder(resp.Body).Decode(&playlist); err != nil {
		return nil, err
	}

	return &playlist, nil
}

// Helper function to search for a Spotify track
func searchSpotifyTrack(accessToken, title, artist string) (string, error) {
	query := fmt.Sprintf("track:%s artist:%s", title, artist)
	encodedQuery := url.QueryEscape(query)
	
	url := fmt.Sprintf("%s?q=%s&type=track&limit=1", searchURL, encodedQuery)
	
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return "", err
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf("failed to search track: %s - %s", resp.Status, string(body))
	}

	var searchResponse SpotifySearchResponse
	if err := json.NewDecoder(resp.Body).Decode(&searchResponse); err != nil {
		return "", err
	}

	if len(searchResponse.Tracks.Items) == 0 {
		return "", fmt.Errorf("no tracks found for %s by %s", title, artist)
	}

	return searchResponse.Tracks.Items[0].URI, nil
}

// Helper function to add tracks to a Spotify playlist
func addTracksToPlaylist(accessToken, playlistID string, trackURIs []string) error {
	// Spotify API has a limit of 100 tracks per request
	const maxTracksPerRequest = 100
	
	for i := 0; i < len(trackURIs); i += maxTracksPerRequest {
		end := i + maxTracksPerRequest
		if end > len(trackURIs) {
			end = len(trackURIs)
		}
		
		batch := trackURIs[i:end]
		tracksData := AddTracksTBody{URIs: batch}
		
		jsonData, err := json.Marshal(tracksData)
		if err != nil {
			return err
		}

		url := fmt.Sprintf(addTracksURL, playlistID)
		req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
		if err != nil {
			return err
		}

		req.Header.Set("Authorization", "Bearer "+accessToken)
		req.Header.Set("Content-Type", "application/json")

		client := &http.Client{}
		resp, err := client.Do(req)
		if err != nil {
			return err
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusCreated && resp.StatusCode != http.StatusOK {
			body, _ := io.ReadAll(resp.Body)
			return fmt.Errorf("failed to add tracks to playlist: %s - %s", resp.Status, string(body))
		}
	}

	return nil
}